<?php

/**
 * @file
 * Message tracking feature module for Drupal SMS Framework.
 *
 * @package sms
 * @subpackage sms_track
 */

use Drupal\sms\Message\SmsMessageResultInterface;
use Drupal\sms\Plugin\SmsGatewayPluginInterface;
use Drupal\sms\Message\SmsMessageInterface;
use Drupal\views\Plugin\views\query\QueryPluginBase;
use Drupal\views\ViewExecutable;
use Drupal\sms\Entity\SmsGatewayInterface;

/**
 * Implements hook_help().
 */
function sms_track_help($path, $arg) {
  $output = '';
  switch ($path) {
    case "admin/help#sms_track":
      $output = '<p>' . t("<i>TO BE RE-WRITTEN</i> This module simply records all incoming and outgoing SMS messages from the SMS Framework. This can be used to enable an audit trail for your system, so that you can investigate any issues and keen an eye on what is flowing in and out.<br /><br /><strong>Outgoing: </strong>It is important to be aware of your outgoing SMS traffic because user spamming can be expensive for you, and may also expose you to legal issues. A small code error can cause this kind of problem.<br /><br /><strong>Incoming: </strong>The proper handling of inbound messages depends heavily on the quality of your software code. You may find that someone is sending malformed messages to your gateway receiver, which could expose a vulnerability and potentially release sensitive data.<br /><br />This module uses a database table to store messages, and implements Views for reporting.") . '</p>';
      break;
  }
  return $output;
}


/**
 * Implements hook_cron().
 */
function sms_track_cron() {
  // Ensure that we only run at most once per hour
  $last_run = \Drupal::state()->get('sms_track.archive_cron_last_run', 0);
  $time_an_hour_ago = REQUEST_TIME - 3600;
  if ($last_run <= $time_an_hour_ago) {
    // Purge the archive
    sms_track_archive_purge();
    \Drupal::state()->set('sms_track.archive_cron_last_run', REQUEST_TIME);
  }
}

/**
 * Implements hook_sms_send().
 */
function sms_track_sms_send(SmsMessageInterface $sms) {
  // Tracking.
  // Place a tracking reference on a sent message if we need to.
  if (!empty($options) && !array_key_exists('reference', $options)) {
    $options['reference'] = md5(implode(',', $sms->getRecipients()) . $sms->getMessage());
  }
}

/**
 * Implements hook_sms_send_process().
 */
function sms_track_sms_send_process($op, SmsMessageInterface $sms, SmsMessageResultInterface $result = NULL) {
  if ($op == 'post process') {
    // Archiving (outgoing == 0)
    $dir = 0;
    $options = (isset($options) && is_array($options))? $options : array();
    $options['gateway_id'] = $sms->getGateway()->id();
    $options['result']  = $result;
    $message = $sms->getMessage();
    foreach ($result->getReports() as $report) {
      $options['reference'] = $report->getMessageId();
      sms_track_archive_write($dir, $report->getRecipient(), $message, $options);
    }
  }
}


/**
 * Implements hook_sms_incoming_preprocess().
 */
function sms_track_sms_incoming_preprocess(SmsMessageInterface $sms_message) {
  $message = $sms_message->getMessage();
  // Archiving (incoming == 1)
  $dir = 1;
  foreach ($sms_message->getRecipients() as $number) {
    sms_track_archive_write($dir, $number, $message, []);
  }
}


/**
 * Implements hook_sms_receipt().
 *
 * @param string $op
 *   Operation string.
 * @param \Drupal\sms\Message\SmsDeliveryReportInterface[] $reports
 *   Delivery reports received from the SMS gateway.
 * @param array $options
 *   Additional options array.
 */
function sms_track_sms_receipt($op, array $reports, array $options) {
  if ($op == 'pre process') {
    // Tracking.
    sms_track_update_message($reports);
  }
}


/**
 * Writes a record to the DB table.
 *
 * @param int $dir
 *   Direction of message transmission (0=outgoing, 1=incoming).
 * @param string $number
 *   MSISDN of recipient or sender.
 * @param string $message
 *   SMS message body.
 * @param array $options
 *   (optional) an array of additional options.
 */
function sms_track_archive_write($dir, $number, $message, array $options = array()) {
  $user = \Drupal::currentUser();
  $archive_dir = \Drupal::config('sms_track.settings')->get('archive_dir');
  // Query the database for the uid of the user that owns the $number
  if (\Drupal::moduleHandler()->moduleExists("sms_user")) {
    $remote_user = sms_user_get_uid($number);
  }
  else {
    $remote_user = false;
  }

  $reference = $author = $recipient = $status = NULL;
  if ($dir == 0) {
    // Outgoing
    if ($archive_dir == SMS_DIR_ALL || $archive_dir == SMS_DIR_OUT) {
      $reference = (array_key_exists('reference', $options)) ? $options['reference'] : NULL;

      // Status code may be provided by send result handler
      $status = (is_array($options['result'])) ? $options['result']['status_code'] : NULL;

      // Or render a status code from a simple true/false result
      if (! $status) {
        if ($options['result']) {
          $status = SmsGatewayPluginInterface::STATUS_OK;
        }
        else {
          $status = SmsGatewayPluginInterface::STATUS_ERR_OTHER;
        }
      }
      // Add the author and recipient
      $author = $user->id();
      $recipient = ($remote_user) ? $remote_user : 0;
    }
    else {
      return;
    }
  }
  elseif ($dir == 1) {
    // Incoming message.
    if ($archive_dir == SMS_DIR_ALL || $archive_dir == SMS_DIR_IN) {
      $reference = NULL;
      // Inbound message status is always the same.
      $status = SmsMessageInterface::STATUS_OK;
      // Add the author and recipient
      $recipient = $user->id();
      $author = ($remote_user) ? $remote_user : 0;
    }
    else {
      return;
    }
  }

  $gw_number = (isset($options) && is_array($options) && array_key_exists('gw_number', $options)) ? $options['gw_number'] : NULL;
  $created   = REQUEST_TIME;
  $options_z = serialize($options);

  // Write the record to the database.
  $result = $id = db_insert('sms_track')
    ->fields(array(
      'reference' => $reference,
      'dir' => $dir,
      'number' => $number,
      'gw_number' => $gw_number,
      'message' => $message,
      'status' => $status,
      'created' => $created,
      'options' => $options_z,
      'author' => $author,
      'recipient' => $recipient,
    ))
  ->execute();

  if (! $result) {
    $to_from = ($dir == 0) ? 'To' : 'From';
    \Drupal::logger('sms_track')->error('Failed to record message: ' . $to_from . ' ' . $number . ': ' . $message);
  }
}

/**
 * Updates message reports with the new delivery status codes.
 *
 * @param \Drupal\sms\Message\SmsDeliveryReportInterface[] $reports
 *   The SMS delivery reports.
 *
 * @todo Log record handling.
 */
function sms_track_update_message(array $reports) {
  $updated = REQUEST_TIME;
  $affected_rows = 0;

  foreach ($reports as $number => $report) {
    \Drupal::logger('sms_track')
      ->notice($report->getMessageId() . ' ' . $report->getStatus() . ' ' . $updated);

    $result = db_update('sms_track')
      ->fields(array(
        'status' => $report->getStatus(),
        'updated' => $updated,
      ))
      ->condition('reference', $report->getMessageId())
      ->execute();
    $affected_rows += $result->rowCount();
  }

  if ($affected_rows) {
    \Drupal::logger('sms_track')->notice('Affected rows: ' . $affected_rows);
  }
}


/**
 * Purges all archived messages after a certain number of days.
 *
 * @param int $max_age_days
 *   (optional) Maximum age of tracked messages in days. If null or not supplied,
 *     the pre-configured value is used (default is 0).
 */
function sms_track_archive_purge($max_age_days = NULL) {
  // Get the configured max_age from the variable table if not given.
  if (is_null($max_age_days)) {
    $max_age_days = \Drupal::config('sms_track.settings')->get('archive_max_age_days');
  }
  // Purge with no survivors.
  if ($max_age_days > 0) {
    $max_age_secs = $max_age_days * 86400;
    $oldest = REQUEST_TIME - $max_age_secs;
    db_delete('sms_track')
      ->condition('created', $oldest, '<')
      ->execute();
  }
}

/**
 * Implements hook_views_query_alter().
 */
function sms_track_views_query_alter(ViewExecutable $view, QueryPluginBase $query) {
  // Use an OR condition for the contextual filters.
  if ($view->storage->id() == 'my_messages') {
    $query->where[0]['type'] = 'OR';
  }
}
